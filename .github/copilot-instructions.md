<!-- Autogenerated guidance for AI coding agents. Keep concise and actionable. -->
# Copilot instructions for Laminación Scheduler (concise)

This file tells coding agents the minimal, project-specific knowledge needed to be productive in this repo.

1) Big picture
- Purpose: `Laminación Scheduler` sequences production orders and inserts setup/maintenance stops
  using explicit business rules (changeovers, quality changes, ring/channel maintenance and peak-hour rules).
- Frontend-only app (React + Vite + TypeScript) that simulates a timeline in-browser; persistence is local (Zustand).

2) Where to start reading (order matters)
- High-level: [README.md](README.md) — Spanish, explains business rules and intent.
- App shell: [src/App.tsx](src/App.tsx) and [src/main.tsx](src/main.tsx) — navigation and component wiring.
- Scheduling engine: [src/utils/schedulerLogic.ts](src/utils/schedulerLogic.ts) — central simulation logic (`simulateSchedule`, peak/ring/channel rules).
- State & orchestration: [src/store/useStore.ts](src/store/useStore.ts) — pre-processing, calls `simulateSchedule`, persistence key `scheduler-storage`.
- UI components to inspect: [src/components/ProductionScheduler.tsx](src/components/ProductionScheduler.tsx), [src/components/VisualSchedule.tsx](src/components/VisualSchedule.tsx), [src/components/DatabaseLayout.tsx](src/components/DatabaseLayout.tsx).

3) Developer workflows & commands
- Run dev server: `npm run dev` (Vite). Use this to iterate fast.
- Build for production: `npm run build` — runs `tsc -b && vite build` (TypeScript build is required before Vite build).
- Lint: `npm run lint` (ESLint configured).
- No unit tests found in repo; validate changes by running `dev` and exercising UI flows.

4) Important conventions & gotchas (project-specific)
- Language: Documentation, variable names and UI copy are primarily Spanish — prefer Spanish context when editing business rules.
- State model: `useStore` (Zustand) persists parts of state under localStorage key `scheduler-storage`. To repro a clean state, clear local storage or use the app import/clear features.
- Recalculation: `useStore.recalculateSchedule()` is the single place that re-runs the simulation. Changing scheduling inputs must preserve pre-processing in `recalculate()` (see `useStore.ts`).
- Durations are minutes (often integers); production time is computed as `(quantity / ritmoTH) * 60` in `useStore.ts`.
- Peak/hour-window logic and maintenance rules live in `schedulerLogic.ts` — mirror README rules there if you change behavior.

5) External libraries and integration points
- AG Grid: `ag-grid-community` + `ag-grid-react` — used for tabular editing.
- Zustand: persistent client state (no backend). Changes to store shape require migration or cautious partialize logic.
- date-fns: all date arithmetic uses `date-fns` functions (format `yyyy-MM-dd` for holidays).
- xlsx/uuid used for import/export and id generation.

6) Editing guidance for agents (practical checks)
- When modifying scheduling logic:
  - Update `src/utils/schedulerLogic.ts`, then run the app and confirm the UI timeline updates.
  - Ensure `useStore.recalculateSchedule()` still produces the same contract (items with `computedStart`, `computedEnd`, and `segments`).
  - Keep the same segment `type` strings (e.g., `production`, `setup`, `ring_change`, `channel_change`, `maintenance_hp`, `forced_stop`) — UI expects them.
- When changing persisted state shape, update the `partialize` function in `useStore.ts` and consider migration strategy.
- Prefer small, incremental patches: run `npm run lint` and `npm run build` locally before proposing PR.

7) Useful examples (copy-paste references)
- Find peak maintenance insertion: `src/utils/schedulerLogic.ts` — function `calculatePeakCoverage` and `getPeakBounds`.
- Preprocessing rates and changeover lookup: `src/store/useStore.ts` — function `recalculate` and `simulateSchedule` invocation.

8) Where to ask questions
- Domain/business logic questions: refer to [README.md](README.md) (Spanish) — it documents the rules intentionally.
- Repo-owner or maintainers: leave a PR comment and request clarification on how a given change should affect the scheduling rules.

If anything here is unclear or you want the instructions expanded with examples or additional file links, say which area to expand.
